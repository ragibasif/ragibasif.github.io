---
title: "Build a Dynamic Array in C From Scratch"
description: "How to Build a Dynamic Array in C"
pubDate: "September 12 2025"
updatedDate: "September 12 2025"
tags: ["C", "Data Structures", "Tutorial"]
featured: true
---

Dynamic arrays are a fundamental data structure in computer science. Unlike static arrays, they automatically resize themselves to accommodate new elements.
In this post, we will build a minimal dynamic array in C from scratch with no external libraries.

## Lets Get Started

We will start with creating three files:

```sh
touch DynamicArray.h DynamicArray.c main.c
```

- `DynamicArray.h` - API declarations will go here
- `DynamicArray.c` - Implementation will go here
- `main.c` - demo and testing will be done here

## API

```c
// DynamicArray.h
typedef struct {
    int   *buffer;
    size_t size;
    size_t capacity;
} DynamicArray;

extern void DynamicArrayInit(DynamicArray *array, int size);
extern void DynamicArrayPushBack(DynamicArray *array, int item);
extern void DynamicArrayPrint(DynamicArray *array);
extern void DynamicArrayPopBack(DynamicArray *array);
extern void DynamicArrayCleanup(DynamicArray *array);
```

## Implementation

### Initialization

`extern void DynamicArrayInit(DynamicArray *array, int size);` - initializes the array and allocates memory

```c
// DynamicArray.c

#include "DynamicArray.h"

void DynamicArrayInit(DynamicArray *array, int size) {
    if (size <= 0) { size = 1; }
    array->size     = 0;
    array->capacity = size * 2;
    array->buffer   = malloc(sizeof *array->buffer * array->capacity);
    memset(array->buffer, 0, sizeof *array->buffer * array->capacity);
}
```

### Adding Elements

`extern void DynamicArrayPushBack(DynamicArray *array, int item);` - appends elements and expands the capacity if needed

```c
void DynamicArrayPushBack(DynamicArray *array, int item) {
    if (array->size >= array->capacity) {
        array->capacity *= 2;
        array->buffer = realloc(array->buffer,
                                sizeof *array->buffer * array->capacity);
    }
    array->buffer[array->size++] = item;
}
```

### Removing Elements

`extern void DynamicArrayPopBack(DynamicArray *array);` - removes the last element from the array, does nothing if array is empty

```c

void DynamicArrayPopBack(DynamicArray *array) {
    if (!(array->size > 0)) { return; }
    array->size--;
}
```

### Printing Elements

`extern void DynamicArrayPrint(DynamicArray *array);` - prints all the elements in the array, does nothing if array is empty

```c
void DynamicArrayPrint(DynamicArray *array) {
    for (int i = 0; i < array->size; i++) {
        printf("%d ", array->buffer[i]);
    }
    putchar('\n');
}
```

### Clean Up

`extern void DynamicArrayCleanup(DynamicArray *array);` - frees the memory

```c

void DynamicArrayCleanup(DynamicArray *array) {
    if (!array->buffer) { return; }
    array->size = array->capacity = 0;
    free(array->buffer);
    array->buffer = NULL;
}
```

### Helpers

```c
// DynamicArray.c
#define ALLOC_CHECK( ptr, size ) \
    alloc_check( ptr, size, __FILE__, __LINE__, __func__ )
#define REALLOCATE( ptr, size ) reallocate( ptr, size )

static void alloc_check( void *ptr, const size_t size, const char *file,
                         const int line, const char *func );
static int *reallocate( void *ptr, const size_t size );

static int *reallocate( void *ptr, const size_t size ) {
    int *tmp = realloc( ptr, size );
    ALLOC_CHECK( ptr, size );
    ptr = tmp;
    return ptr;
}

static void alloc_check( void *ptr, const size_t size, const char *file,
                         const int line, const char *func ) {
    if ( !ptr ) {
        fprintf( stderr,
                 "[%s:%u:(%s)] Memory allocation error. Failed to allocate %lu "
                 "bytes to memory address %p.\n",
                 file, line, func, size, (void *)ptr );
    }
}
```

- `static void alloc_check( void *ptr, const size_t size, const char *file,
const int line, const char *func );` - will check to see if memory was allocated successfully
- `static int *reallocate( void *ptr, const size_t size );` - expands the capacity
- `ALLOC_CHECK( ptr, size )` - wrapper around `alloc_check`
- `REALLOCATE( ptr, size )` - wrapper around `reallocate`

### Updated Functions

```c
// DynamicArray.c

void DynamicArrayInit( DynamicArray *array, int size ) {
    if ( size <= 0 ) { size = 1; }
    array->size     = 0;
    array->capacity = size * 2;
    array->buffer   = malloc( sizeof *array->buffer * array->capacity );
    ALLOC_CHECK( array->buffer, array->capacity );
    memset( array->buffer, 0, sizeof *array->buffer * array->capacity );
}


void DynamicArrayPushBack( DynamicArray *array, int item ) {
    if ( array->size >= array->capacity ) {
        array->capacity *= 2;
        array->buffer = REALLOCATE( array->buffer,
                                    sizeof *array->buffer * array->capacity );
    }
    array->buffer[array->size++] = item;
}


```

## Example Usage

```c
// main.c

#include "DynamicArray.h"

int main([[maybe_unused]]int argc, [[maybe_unused]]char **argv) {
    DynamicArray arr;
    DynamicArrayInit(&arr, 4);

    for (int i = 0; i < 10; i++) {
        DynamicArrayPushBack(&arr, i+1);
    }

    DynamicArrayPrint(&arr);  // Output: 1 2 3 4 5 6 7 8 9 10
    DynamicArrayPopBack(&arr);
    DynamicArrayPrint(&arr);  // Output: 1 2 3 4 5 6 7 8 9

    DynamicArrayCleanup(&arr);
    return 0;
}
```

## Compile and Run

```sh
gcc DynamicArray.c main.c -o dynamic_array
./dynamic_array
```

## Code

The most updated version of the code can be found in the GitHub repository at
<a href="https://github.com/ragibasif/DynamicArray.c" target="_blank" rel="noopener noreferrer">DynamicArray.c</a>.
